from django.db import models
from django.utils import timezone
# Встроенный в Django фреймворк аутентификации располагается
# в пакете django.contrib.auth и содержит модель User (Пользователь). Модель User будет применяться из указанного фреймворка аутентификации, чтобы создавать взаимосвязи между пользователями и постами.
from django.contrib.auth.models import User

# Create your models here.

# Модель дозволить зберігати пости блогу в БД
class Post(models.Model):
    
    # поле статусу, яке дозволить керувати статусом постів
    # блогу. У постах будуть використовуватися статуси Draft (Чернетка) та Published(Опубліковано).
    class Status(models.TextChoices):
        DRAFT = 'DF', 'Draft'
        PUBLISHED = 'PB', 'Published'
        
    title = models.CharField(max_length=250) # Заголовок
    slug = models.SlugField(max_length=250) # коротка мітка - slug
    # Поле SlugField транслюється в стовпець VARCHAR в БД.
    # Слаг – це коротка мітка, що містить лише літери, цифри,
    # знаки підкреслення або дефіси
    
    author = models.ForeignKey(User, # взаємозв'язок багато-
        # до одного, що означає, що кожен пост написаний користувачем і користувач може написати будь-яку кількість постів
        on_delete=models.CASCADE, # Параметр on_delete визначає поведінку, яку слід застосовувати
        # для видалення об'єкта, на який є посилання. Ця поведінка не відноситься безпосередньо до Django; воно є стандартним для SQL. Використання
        # ключового слова CASCADE вказує на те, що при видаленні користувача, на
        # якого є посилання, база даних також видалить всі пов'язані з ним пости у блозі.
        related_name='blog_posts') # Ми використовуємо related_name, щоб вказувати ім'я зворотного зв'язку від User
        # до Post. Такий підхід дозволить легко звертатися до пов'язаних об'єктів з 
        # об'єкта User, використовуючи позначення user.blog_posts.
    
    body = models.TextField() # Тіло поста
    
    publish = models.DateTimeField(default=timezone.now) # транслюється в стовпець DATE­TIME в БД, дата і час публікації поста. timezone.now - повертає поточну дату та час 
    created = models.DateTimeField(auto_now_add=True) # Дата і час створення поста. auto_now_add - дата автоматично зберігається при створенні об'єкту 
    updated = models.DateTimeField(auto_now=True) # остання дата і час оновлення поста. auto_now - дата оновлюється автоматично при збереженні об'єкту
    
    # Ми визначили перерахований клас Status шляхом підкласування
    # класу models.TextChoices. Доступними варіантами статусу посту є
    # DRAFT та PUBLISHED. Їхніми відповідними значеннями виступають DF і PB, а їх мітками або іменами, що читаються, є Draft і Published.
    status = models.CharField(max_length=2,
                            choices=Status.choices,
                            default=Status.DRAFT)
    
    class Meta: # Клас визначає метаданні моделі
        ordering = ['-publish'] # Сортує результати по полю publish, пости будуть зберігатися в оберненому хроногологічному порядку(-)
        indexes = [ # індекс покращить ефективність запитів, 
        # фільтруючих або впорядковуючих результати по вказаному 
        # полю, перед ім'ям поля застосовано дефіс, щоб визначити
        # індекс у спадному порядку
            models.Index(fields=['-publish']),
        ]
        # Індексне впорядкування MySQL не підтримується. Якщо використовуєте MySQL, то спадний індекс буде створюватися як простий індекс.
        
    def __str__(self): # Заголовок кожного об'єкта в адмін-панелі
        return self.title